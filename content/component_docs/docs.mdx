# Docs

## Editor

Use ‚å•+s (option+s) to save. This is required or all data will be lost. This is not done automatically to avoid a huge number of writes to the database that would increase operational cost.

## Mdx

Mdx is a superset of markdown, a combination of [React's](https://react.dev/) `jsx` language with markdown, the (ironically, 'markup' language) that's used in apps like [Notion](https://www.notion.com/) and [Obsidian](https://obsidian.md/).  

Mdx gets parsed to html, which can be styled to blend in and function along with our existing application. There's a solid breakdown of the default markdown elements [here](https://www.markdownguide.org/basic-syntax/) and how they convert to html, along with examples of all of the syntax. Before the jsx is even added, there are multiple popular 'flavors' of markdown, with the 'github flavor' being the most popular with added support for things like footnotes. All Github Flavored Markdown features are enabled in this application. 

With the addition of jsx to markdown however, a developer can write components that interact with the entire application that also compile to html, but in a more complex way. This uses a special `jsx` syntax. I'll do my best to cover what I think isn't obvious from the examples here.

### Jsx

Components will always start with a capital letter, be one word, and will never include any special characters. To call a component, you use an opening `<` bracket followed by the component's name, a list of properties that is unique to each component type, and a set of closing brackets. There are actually two types of closing brackets, with the only difference being if the component is being passed any 'children'. 

`children` is just a special property that represents things that go inside of the parent. A big part of why `jsx` was created was to more easily model this `children` property in a way that aligns with the way we naturally organize this type of property in our heads, making things much easier to read, but in the end this `children` property is just like any other property, only implemented in a different way.  Think of a layout component like our `Align` component. This component doesn't render anything on it's own, although that's not a strict requirement of components that accept `children`, but it changes the position of the components that are inside of it; this is when developers usually choose to represent a property as a 'child'.

**Remember:** Sometimes the children property will be just regular markdown, other times it might be expecting a specific type of children like a specific component or a specific number of children to implement the intended layout. If that's the case that will be noted with the component's examples below. This type of error will not cause an issue with the computer and will possibly go unnoticed, but it can cause unintended layouts at different screen sizes.

If a component accepts a child, it is written as:

```tsx
<MyComponent>
The children in this case will be a paragraph of text that says 'The children....'
</MyComponent>
```

If does is not, you don't need the second instance of it's name and you can just write as follows. This is common for things like inputs where nothing really belongs inside of it.


```tsx
<MyComponent />
```


### Providing Properties

There are a handful of different types of properties you can provide to mdx components, but they'll be documented here only if they actually occur in our components.


#### String

This is the most common, and unfortunately the only one that's even remotely challenging. Since the 'x' in mdx is really just 'jsx', it's required to know a little about how javascript handles strings. The key points are:

1. You can use any quotation mark, so long as you use the same quotation mark to both open and close the string.
2. Wrapping the value, including the quotation marks with curly brackets `{}` is optional for both `'` and `"`, but is required for `\``
3. Using the back-tick, `\`` (top left of keyboard) gives slightly more freedom, allowing for the use of multiple lines
4. If you really _need_ to include the same quotation mark that you're using to open and close the string within the string itself, you need to escape it with a leading `\` character. This ends up looking like `"This is my \"quote\" within a string"`

#### Boolean

A boolean is just a `true` or `false` value. To make things even more simple, a property is most often assumed to be false, and is automatically set to true if you don't assign a value, so just writing the property name is the same as setting it to true. This means that 

```tsx
<Checkbox 
    initiallyChecked={true}
  />
```

and

```tsx
<Checkbox 
    initiallyChecked
  />
```

are the same thing, where as just removing the `initiallyChecked` all together assumes the value is false.

#### Arrays

Arrays are just ordered lists of some other type in javascript. They're written with a pair of square brackets `[]` with a list of comma-separated values as they would be written elsewhere. For an array of strings that means the same string that quotation rules apply, and the same for the object notation below.

#### Objects

Objects are just a group of properties that all represent the same thing in some sense. The `ReorderInput` component accepts a list of options that is an array of objects with the properties `title`, `subtitle` and `value`.

This is written as:

```tsx 
options={[
    {
        title: "Option 1",
        value: "1"
    }, // Notice the comma here.
    {
        title: "Option 2", // and the commas here.
        subtitle: "Option 2 has an optional subtitle",
        value: "2"
    }
]}
```

While the spacing within the string will appear as white space within that string, the pretty indentation is completely optional.

# Components, the 'x' in mdx

Jsx is a language developed initially by Facebook for it's portability and readability. It can become quite complicated as it's just a superset of a regular programming language, javascript. While complicated in it's entirety, any capable developer should be able to wrap complex layouts in a set of simple, easy to use properties, making the actual usage of those components almost as simple as markdown.

## Input Components

For stylistic reasons, the `maxWidth` property is only applied when the viewport is wide enough. Below this width everything will collapse to being full-width and a single column to accommodate the smaller viewport.


### Text Input

```tsx
<TextInput 
    label={`My Label`}
    // This 'name' field is associated with this value in the database.
    // What matters most is that it is unique,
    // and that it never changes once a user has inserted data.
    name={"anyUniqueNameThatNeverChanges"}
    // This placeholder field is optional.
    placeholder="Company Name"
    // "small" | "medium" | "large" | "full"
    // If none provided, default is "full"
    maxWidth="large"
/>
```

Produces:


<TextInput 
    label={`My Label`}
    name={"anyUniqueNameThatNeverChanges"}
    placeholder="Company Name"
    maxWidth="large"
/>



### Multiline Input

All of the properties here are the same as in the `EmbeddableTextInput` component.

```tsx
<MultiLineTextInput
    label={`My Label`}
    name={"anyUniqueNameThatNeverChanges2"}
    placeholder="Company Name"
    // "small" | "medium" | "large" | "full"
    // If none provided, default is "full"
    maxWidth="medium"
    // The number of rows to make the input. 
    // The input is resizable, but this will be
    // it's initial size
    // defaults to 3 if not present.
    rows={3}
/>
```


<MultiLineTextInput
    label={`My Label`}
    name={"anyUniqueNameThatNeverChanges2"}
    placeholder="Company Name"
    rows={3}
    maxWidth="medium"
/>


### Checkbox Input

For boolean questions like 'should I contact you by email', you can use a checkbox. 

```tsx
<Checkbox
    name="My name that never changes"
    title="My title"
    subtitle="This subtitle is optional." 
/>
```


<Checkbox name="My name that never changes" title="My title" subtitle="This subtitle is optional." />


### Date-Time Input

**With Time:**

```tsx
<DateInput 
    name="My unique, descriptive name."
    time
/>
```

<DateInput 
    name="My unique, descriptive name."
    time
/>


### Reorder Input

```tsx
<ReorderInput 
    name="myUniqueUnchangingName"
    title="A title is optional"
    subtitle="A subtitle is optional too!"
    options={[
        {
            title: "Option 1",
            // This can be either a string or a number.
            // This is the value that will be stored in the
            // database and visible only to admins.
            value: 1 
        },  
        {
            title: "Option 2",
            subtitle: "Subtitles are optional",
            // Make sure the same value doesn't appear twice
            // in the same list.
            value: 2
        },
        {
            title: "Option 3",
            subtitle: "Subtitles are optional",
            value: 3
        },
    ]}
/>
```


<ReorderInput 
    name="myUniqueUnchangingName"
    title="A title is optional"
    subtitle="A subtitle is optional too!"
    options={[
        {
            title: "Option 1",
            // This can be either a string or a number.
            // This is the value that will be stored in the
            // database and visible only to admins.
            value: 1 
        },  
        {
            title: "Option 2",
            subtitle: "Subtitle's are optional",
            // Make sure the same value doesn't appear twice
            // in the same list.
            value: 2
        },
        {
            title: "Option 3",
            subtitle: "Subtitle's are optional",
            value: 3
        },
    ]}
/>


### Submit

This is a simple button that submits the form, but has several useful properties. Below are the default values. All properties are optional, so it can just be written as `<Submit />` if the defaults are ok.

```tsx
<Submit 
    // The text content of the button.
    label={"Submit"}
    // The notification if the submission
    // is successful.
    notificationTitle={"Thank you"}
    notificationBody={"Form submitted successfully"}
    // The notification if the submission
    // encounters an error.
    notificationErrorTitle={"Oh no."}
    notificationErrorBody={"An error occurred. Someone will address this as soon as possible."}
/>
```

On the editor page, this component will print out the form's data to the browser's developer console (cmd+opt+i in chrome) instead of writing it to the database.


## Layout Components

Remember to consider the width of the preview when viewing these layout components, as much of their intended functionality is to respond to different screen sizes.

### Grid 

```tsx
<Grid
    // This is the default value for this property. 
    // You can also use a regular integer as columns={2}
    // to apply the same number of columns to all screen sizes
    columns={{
        small: 1,
        medium: 1,
        large: 2
    }}
    // This will reverse the order of things when the grid collapses to 
    // a single column. This is necessary to achieve certain alternating layouts.
    reverse
>
    <Align>
        This will be in the center of the first column
    </Align>
    <Align>
        This will be in the center of the second column
    </Align>
</Grid>
```


<Grid
    columns={{
    small: 1,
    medium: 1,
    large: 2
    }}
    reverse
>
    <Align>
        This will be in the center of the first column
    </Align>

    <Align>
        This will be in the center of the second column
    </Align>
</Grid>


### Align

By default, the `Align` component will try to center things within it's parent, but there are many other layouts that can be achieved with this component.

It accepts the following properties:

| Property | Options | Default |
| -------- | ------- | ------- |
| vertical | "top", "bottom", "center" | "center" |
| horizontal | "left", "right", "center" | "center" |
| width | "fit", "full" | "full" |

Leaving the properties empty will apply all of the defaults, centering the content as in the example above.


## General UI Components

### Image

Markdown has it's own image syntax, `![Some descriptive text](linkToImageHere)`, but there is also a much more powerful component available. The natively supported markdown images inserted with the syntax mentioned previously are styled to not completely ruin the style of the application, but it's not possible to style a component for every use case. That's where jsx's properties excel. The image component has several properties, many of which are optional, but you're almost always going to want to apply a `maxWidth` property and either a `left` or a `right` property for most vertical layouts.



| Property | Options | Default |
| -------- | ------- | ------- |
| url | any string (the url of the image) | Required property |
| alt | any string | Required property |
| maxWidth | "small", "medium", "large" or any number | undefined |
| maxHeight | "small", "medium", "large" or any number | undefined |
| left | true, false | false |
| right | true, false | false |

Here, the `left` property 'floats' the image to the left when the screen is large enough, wrapping text around the image. `right` of course does the same thing on the other side. The `alt` property is some alternative text to display for people with visual disabilities and search engines, and the `url` property is the url of the image itself. The only two properties that are required are `url` and `alt`, but when the component is not wrapped in another layout component, you'll almost always want to use `maxWidth` and either `left` or `right`.


#### An example with some lorem ipsum text to demonstrate text wrapping

This is some example text wrapping around an image with the following content:

```tsx
<Image 
    // picsum is a random image provider,
    // this app has the ability to provide your 
    // own via AWS. See the media page...
   url={"https://picsum.photos/200/300?grayscale"}
   alt="Some alternative description here."
   maxWidth="medium"
   left
/>
```

Pharetra integer nulla volutpat pharetra convallis tristique magna nulla cursus. Nec morbi nunc arcu, a eu eget ut at diam. Dignissim pretium ut, porttitor lacus convallis diam, elit lectus id. Imperdiet nisl id dictum dictum, vulputate, vestibulum facilisis sed nullam. Ultricies laoreet consectetur est amet turpis, lectus consectetur cursus velit.

<Image 
   url={"https://picsum.photos/200/300?grayscale"}
   alt="Some alternative description here."
   maxWidth="medium"
   left
/>

Tempor maximus dignissim viverra sed eu aliquet, massa platea porta. Convallis eget pretium amet sed aliquam ligula aliquam porta in. Turpis libero condimentum sed ac congue ac luctus auctor sed. Risus metus montes, ornare laoreet ut hac, ultrices ultricies risus. Nisl et velit velit, nibh ornare urna tincidunt dictumst enim.

Erat, consectetur, nec faucibus gravida id sed aenean elit rhoncus. In lorem lobortis consectetur vel iaculis et adipiscing, eu etiam. Nisl montes lacus praesent, nunc ultrices eget praesent ipsum vulputate. Quis ut diam a praesent pellentesque dictumst pharetra volutpat, tempor. Posuere laoreet metus et nibh at eget nullam efficitur nunc.

Sit id massa ac nibh velit phasellus, condimentum vel, suscipit. Diam duis porta massa dignissim ut dui laoreet convallis augue. Placerat proin eget, ac arcu tristique lacus pharetra elit suscipit. Convallis vestibulum nullam luctus, faucibus amet praesent in consectetur tempor. Tristique porta, nullam faucibus diam in nisl sed efficitur ipsum.

Ullamcorper id, dignissim iaculis ante faucibus varius, venenatis metus praesent. At aliquam, ligula purus augue nibh at malesuada risus, bibendum. Tristique vulputate laoreet nisi, dui faucibus quis, diam purus et. Aenean eget dui elit quam congue id, elementum, cursus ac. Dignissim ut convallis imperdiet, aliquam id dignissim tincidunt dignissim ligula.

### "Callouts"

```tsx
<Callout title={"This is a _note_ callout"} type="note">
If not foldable, this will be displayed directly and there won't be an icon.
</Callout>

<Callout title={"This is a **tip** callout"} type="tip" foldable>
Set 'foldable' to make the callout foldable.
</Callout>

<Callout title={"This is a **important** callout"} type="important" foldable folded={false}>
Set 'folded={false}' to start in an expanded state when 'foldable'
</Callout>

<Callout title={"This is a **warning** callout"} type="warning" foldable>
Set 'foldable' to make the callout foldable.
</Callout>

<Callout title={"This is a **caution** callout"} type="caution" foldable>
Set 'foldable' to make the callout foldable.
</Callout>

<Callout title={"This is a **Pine** callout"} type="pine" foldable>
Some content shown after opening!
</Callout>

<Callout title={"This is a **Mist** callout"} type="mist" foldable>
Some content shown after opening!
</Callout>

<Callout title={"This is a **Fog** callout"} type="fog" foldable>
Some content shown after opening!
</Callout>

<Callout title={"This is a **Moss** callout"} type="moss" foldable>
Some content shown after opening!
</Callout>

<Callout title={"This is a **Dust** callout"} type="dust" foldable>
Some content shown after opening!
</Callout>

<Callout title={"This is a **Matcha** callout"} type="matcha" foldable>
Some content shown after opening!
</Callout>

<Callout title={"This is a **Cream** callout"} type="cream" foldable right>
Some content shown after opening!
</Callout>
```

<Callout title={"This is a _note_ callout"} type="note">
If not foldable, this will be displayed directly and there won't be an icon.
</Callout>

<Callout title={"This is a **tip** callout"} type="tip" foldable>
Set 'foldable' to make the callout foldable.
</Callout>

<Callout title={"This is a **important** callout"} type="important" foldable folded={false}>
Set `folded={false}` to start in an expanded state when 'foldable'
</Callout>

<Callout title={"This is a **warning** callout"} type="warning" foldable>
Set 'foldable' to make the callout foldable.
</Callout>

<Callout title={"This is a **caution** callout"} type="caution" foldable>
Set 'foldable' to make the callout foldable.
</Callout>

<Callout title={"This is a **Pine** callout"} type="pine" foldable>
Some content shown after opening!
</Callout>

<Callout title={"This is a **Mist** callout"} type="mist" foldable>
Some content shown after opening!
</Callout>

<Callout title={"This is a **Fog** callout"} type="fog" foldable>
Some content shown after opening!
</Callout>

<Callout title={"This is a **Moss** callout"} type="moss" foldable>
Some content shown after opening!
</Callout>

<Callout title={"This is a **Dust** callout"} type="dust" foldable>
Some content shown after opening!
</Callout>

<Callout title={"This is a **Matcha** callout"} type="matcha" foldable>
Some content shown after opening!
</Callout>

<Callout title={"This is a **Cream** callout"} type="cream" foldable right>
Some content shown after opening!
</Callout>

Or pass either `right` or `left` as a boolean to float the callout to that side when the screen is large enough and text will wrap around it.
